# Homework 6_1 [heapsort.cpp]


1. purpose of this code
: This implements the heap sort by using ‘build_max_heap’ function and measure the runtime.
Then, tests result by generating a random input array .


2. function

1)int random(int n)
- input : address of TreeNode
- output : returns r random Integenumber generation function between 0 and n-1

2)void init(HeapType *h)
- input : address of Heap `h`
- output : initializes the Heap `h`

3)void insert_max_heap(HeapType *h, element item)
- input : address of Heap `h`, item to be inserted
- output : inserts the item at proper location in max heap `h`

4)element delete_max_heap(HeapType *h)
- input : address of Heap `h`
- output : deletes the root in max heap `h`

5) void build_max_heap(HeapType *h)
- input : address of Heap `h` not satisfied with the max heap structure.
- output : builds max heap `h` 


6)void heap_sort(HeapType *h, element *a, int n)
- input : address of  Heap `h` , output array to save sorted result , heap_size
- output : sorted element array 'a'

7)bool check_sort_results(element *output, int n)
- input :  element array saving sorted result that need to check whether it is sorted correctly. 
- output : returns true if outputarray is sorted in ascending order



# Homework 6_2 [huffman.cpp]

1. purpose of this code
: Implement the code for encoding and decoding an input data using Huffman 
binary tree. 

2. function

1) void init(HeapType *h)
- input : address of Heap `h`
- output : initializes the Heap `h`

2)int is_empty(HeapType *h)
- input : address of Heap `h`
- output : return true if heap `h` is empty


3)void insert_min_heap(HeapType *h, element item)
- input : address of Heap `h`, item to be inserted
- output : inserts the item at proper location in min heap `h`

4)element delete_min_heap(HeapType *h)
- input : address of Heap `h`
- output : deletes the root in min heap `h`

5)TreeNode *make_tree(TreeNode *left, TreeNode *right)
- input : left child of new node , right child of new node
- output :  generates new node in binary tree

6)void destroy_tree(TreeNode *root)
- input : address of root node
- output : deallocates tree in recursion

7)element huffman_tree(input_huff *huff)
- input : input_huff 
- output : generates huffman binary  tree

8)void huffman_traversal(TreeNode *node)
- input : root node
- output :  m_LUT, m_bit_size ( the huffman codeword from the huffman binary tree)

9)int **mem_2D_int(int row, int col)
- input : row_size, col_size
- output : allocates 2D array memory with given row and col

10)void print_codeword()
- input : X
- output : print codeword (m_LUT)

11)void huffman_encoding(char *str, bits_stream *bits_str)
- input : address of char array to be encoded
- output : encoded data 'bits_stream' is generated using 'm_LUT' generated by the huffman binary tree


12)int huffman_decoding(bits_stream *bits_str, TreeNode *node, char *decoded_str)
- input : encoded data 'bits_stream' , root node of  huffman binary tree,  address where the decoded data will be saved
- output : generates 'decoded_str' and returns length of it
