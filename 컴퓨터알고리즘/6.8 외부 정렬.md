
# 내부 정렬 
- 입력이 주기억 장치(내부 메모리)에 있는 상태에서 정렬이 수행된다.


# 외부 정렬
- 입력의 크기가 매우커서 (ex. 내 메모리는 1GB인데 정렬할 값들이 100GB -> 부분부분 나눠서 정렬해야함)읽고 쓰는 시간이 오래 걸리는
보조 기억 장치에 입력을 저장할 수 밖에 없는 상태에서 수행되는 정렬

- 주기억 장치의 용량이 1GB이고, 입력 크기가 100GB 라면, 어떤 내부 정렬 알고리즘으로도 직접 정렬할 수 없다.
 
 
# 주기억 장치에 수용할 만큼 Read/ Sort 


: 외부 정렬은 입력을 분할하여 주기억 장치에 수용할 만큼의 데이터에 대해서만 내부 정렬을 수행하고, 그 결과를 보조기억장치에 일단 다시 저장
> 100GB 의 데이터를 1GB 만큼씩 주기억 장치로 읽어 들이고, 퀵 정렬과 같은 내부 정렬 알고리즘을 통해 정렬한 후, 다른 보조 기억장치에 저장
![보조](https://user-images.githubusercontent.com/86418674/172447856-b24c1250-c180-4985-88b1-1c82003a9053.png)
=> 이를 반복하면, 원래의 입력이 100개의 정렬된 블록으로 분할되어 보조 기억 장치에 저장.


# 정렬된 블록의 합병
: 정렬된 블록들을 반복적인 합병을 통하여 하나의 정렬된 거대한 블록(100GB)으로 만든다.
- 블록들을 부분적으로 주기억 장치에 읽어 들여서, 합병을 수행하여 부분적으로 보조 기억 장치에 쓰는 과정 반복.
- 블록을 부분적으로 읽어 들인 상황


![합병1](https://user-images.githubusercontent.com/86418674/172448848-e2175cba-af1f-4736-ac48-d321ecc59def.png)
![합병2](https://user-images.githubusercontent.com/86418674/172448855-8e6afc02-2e43-4cf0-b870-0d8b07ebe52d.png)

- 나머지 98개의 블록에 대해서 이와 같이 49회를 반복하면, 2GB 블록이 총 50개 만들어지고
- 그 다음엔 2GB 블록 2개씩 짝을 지워 합병하는 과정을 총 25회 수행하면, 4GB블록 25개가 만들어진다.
- 이러한 방식으로 계속 합병을 진행하면, 블록 크기가 2배로 커지고 블록의 수는 1/2로 줄어들게 되어 결국에는 100GB 블록 하나만 남는다.

- 외부 정렬 알고리즘은 보조 기억장치에서의 읽고 쓰기를 최소화 하는 것이 매우중요
  - 왜냐하면 보조 기억 장치의 접근 시간이 주기억 장치의 접근 시간보다 매우 오래 걸리기 때문이다.
  
 - ExternalSort()
  - M = 주기억 장치의 용량
  - 외부 정렬 알고리즘은 입력이 저장된 보조 기억 장치외에 별도의 보조 기억 장치 사용
  - 알고리즘에서 보조 기억 장치는 'HDD'로


# ExternalSort 알고리즘

입력: 입력 데이터가 저장된 입력 HDD
출력 : 정렬된 데이터가 저장된 출력 HDD

1. 입력 HDD에 저장된 입력을 M만큼씩 주기억 장치에 읽어 들인 후 내부 정렬 알고리즘으로 정렬하여 별도의 HDD에 저장한다. 
다음 단계에서 별도의 HDD는 입력 HDD로 사용되고, 입력 HDD는 출력 HDD로 사용
```
while 입력 HDD에 저장된 블록수 >1
  입력 HDD에 저장된 블록을 2개씩 선택하여, 각각의 블록으로부터 데이터를 부분적으로 주기억 장치에 읽어 들여서 합병을 수행한다. 이떄 합병된 결과는 출력 HDD 에 저장한다.
  단, 입력 HDD에 저장된 블록 수가 홀수일 때에는 마지막 블록은 그대로 출력 HDD에 저장한다. //1패스 수행
  입력과 출력 HDD의 역할을 바꾼다
return 출력 HDD
```

1G 128개 -> 2G 64개 -> 4G 32개 ...-> 128GB 1개

# 시간복잡도
: 외부 정렬은 전체 데이터를 몇 번 처리(읽고 쓰기)하는 가를 가지고 시간 복잡도를 측정

- 패스 : 전체 데이터를 1회 처리하는 것 
- 입력크기의 N이고, 메모리 크기가 M이라고 하면 패스가 수행될때마다 블록 크기가 2배씩 증가 (2M,4M,...2^kM)
- 마지막에 만들어진 1개의 블록 크기가 2^kM이면 이 블록은 입력 전체가 합병된 결과를 가지므로 `2^kM= N` , 이때 K는 while루프가 수행된 횟수

```
2^k = N/M
k = log2(N/M)
```

 시간 복잡도: O(log(N/M)
