
# 내부 정렬 
- 입력이 주기억 장치(내부 메모리)에 있는 상태에서 정렬이 수행된다.


# 외부 정렬
- 입력의 크기가 매우커서 (ex. 내 메모리는 1GB인데 정렬할 값들이 100GB -> 부분부분 나눠서 정렬해야함)읽고 쓰는 시간이 오래 걸리는
보조 기억 장치에 입력을 저장할 수 밖에 없는 상태에서 수행되는 정렬

- 주기억 장치의 용량이 1GB이고, 입력 크기가 100GB 라면, 어떤 내부 정렬 알고리즘으로도 직접 정렬할 수 없다.
 
 
# 주기억 장치에 수용할 만큼 Read/ Sort 


: 외부 정렬은 입력을 분할하여 주기억 장치에 수용할 만큼의 데이터에 대해서만 내부 정렬을 수행하고, 그 결과를 보조기억장치에 일단 다시 저장
> 100GB 의 데이터를 1GB 만큼씩 주기억 장치로 읽어 들이고, 퀵 정렬과 같은 내부 정렬 알고리즘을 통해 정렬한 후, 다른 보조 기억장치에 저장
![보조](https://user-images.githubusercontent.com/86418674/172447856-b24c1250-c180-4985-88b1-1c82003a9053.png)
=> 이를 반복하면, 원래의 입력이 100개의 정렬된 블록으로 분할되어 보조 기억 장치에 저장.


# 정렬된 블록의 합병
: 정렬된 블록들을 반복적인 합병을 통하여 하나의 정렬된 거대한 블록(100GB)으로 만든다.
- 블록들을 부분적으로 주기억 장치에 읽어 들여서, 합병을 수행하여 부분적으로 보조 기억 장치에 쓰는 과정 반복.
- 블록을 부분적으로 읽어 들인 상황


![합병1](https://user-images.githubusercontent.com/86418674/172448848-e2175cba-af1f-4736-ac48-d321ecc59def.png)
![합병2](https://user-images.githubusercontent.com/86418674/172448855-8e6afc02-2e43-4cf0-b870-0d8b07ebe52d.png)

- 나머지 98개의 블록에 대해서 이와 같이 49회를 반복하면, 2GB 블록이 총 50개 만들어지고
- 그 다음엔 2GB 블록 2개씩 짝을 지워 합병하는 과정을 총 25회 수행하면, 4GB블록 25개가 만들어진다.
- 이러한 방식으로 계속 합병을 진행하면, 블록 크기가 2배로 커지고 블록의 수는 1/2로 줄어들게 되어 결국에는 100GB 블록 하나만 남는다.

- 외부 정렬 알고리즘은 보조 기억장치에서의 읽고 쓰기를 최소화 하는 것이 매우중요
  - 왜냐하면 보조 기억 장치의 접근 시간이 주기억 장치의 접근 시간보다 매우 오래 걸리기 때문이다.
  
 - ExternalSort()
  - M = 주기억 장치의 용량
  - 외부 정렬 알고리즘은 입력이 저장된 보조 기억 장치외에 별도의 보조 기억 장치 사용
  - 알고리즘에서 보조 기억 장치는 'HDD'로

