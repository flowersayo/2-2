

# 정점 커버
: 주어진 그래프 G=(V,E)에서 각 간선의 양 끝점들 중에서 적어도 하나의 끝점을 포함하는 점들의 집합들 중에서 최소 크기의 집합을 찾는 문제.

- 그래프의 모든 간선이 정점 커버에 속한 점에 인접해 있다.
  - 정점 커버에 속한 점들로 그래프의 모든 간선을 '커버'하는 것

# 정점 커버 예제
![정점커버](https://user-images.githubusercontent.com/86418674/172497539-ea5ef09c-1473-40df-b0ac-0ff3e5204081.png)


# 집합 커버로 해결하기
- 집합 커버 문제
  - n개의 원소를 가진 집합 U가 있고 U의 부분 집합들을 원소로 하는 집합 F가 주어질때 F의 원소들인 집합들 중에서 어떤 집합들을 선택하여 합집합하면 U와 같게 되는가?
  - 집합 F 에서 선택하는 집합들의 수를 최소화하는 문제.
- 마찬가지로 간선의 수가 가장 많은 정점부터 차례대로.. 

정점 커버 문제의 입력 그래프를 집합 커버 문제의 입력으로 변환하여 집합 커버 알고리즘으로 해를 찾아서, 그 해를 정점 커버의해로 삼는다.


# 극대 매칭
- 매칭이란 각 간선의 양쪽 끝 점들이 중복되지 않는 간선의 집합
- 극대 매칭은 이미 선택된 간선에 기반을 두고 새로운 간선을 추가하려고 해도 **더이상 추가할 수 없는 매칭**을 말한다.
- 극대 매칭을 이용하여 정점 커버를 해결하자 -> 간선의 양 끝점이 이미 커버된 간선의 끝점이 아닐때에만 선택

# 의사코드
![버텍스커버](https://user-images.githubusercontent.com/86418674/172520988-2c0c8b6a-4289-4a31-9ba0-baae4f94ab6c.png)

# 코드
```
g =[ [0,1,0,0,0,0],
     [1,0,1,1,1,0],
     [0,1,0,0,1,1],
     [0,1,0,0,0,0],
     [0,1,1,0,0,1],
     [0,0,1,0,1,0]
    ]
    
    
def vertextCover(adj):
    V=len(adj)
    visited = [False]* V
    c=[]
    
    for u in range(V):
        if visited[u]==False:
            for v in range(V):
                if adj[u][v] != 0 and visited[v]==False: # 길이 존재하고 아직 방문하지 않았다면
                    c.append(u)
                    c.append(v)
                    
                    # 커버된 정점 방문체크
                    visited[u]=True
                    visited[v] = True
                    break
                    
                    
                    
    return c
c= vertextCover(g)
print(c);
```

# 시간 복잡도
- 그래프에서 극대 매칭을 찾는 시간복잡도와 동일
- 극대 매칭을 찾기 위해 하나의 간선을 선택할 때
  - 양 끝점이 이미 선택된 간선의 끝점인지를 검사해야 하므로 O(n)시간
  - 입력 그래프의 간선 수가 m이면, 각 간선에 대해서 O(n)시간
  - 시간 복잡도는 O(n) * m = O(nm)

