# 4.3 최단경로찾기


# 최단 경로 문제 
: 주어진 가중치 그래프에서 어느 한 출발점에서 또 다른 도착점까지의 최단경로를 찾는 문제
대표적인 알고리즘으로는 다익스트라 알고리즘이 있음. 


# 다익스트라 알고리즘
- 주어진 출발점에서 시작
-  출발저믕로부터 최단거리가 확정되지 않은 점들 중에서 출발점으로부터 가장 가까운 점을 추가하고, 그 점의 최단거리를 확정

**의사코드**
입력 : 가중치 그래프 G=(V,E), |V|=n, |E|=m
출력 : 출발점 s 로부터 (n-1)개의 점까지 각각 최단거리를 저장한 배열 D

```
배열 D를 INF 로 초기화. 단 D[s] = 0 으로 초기화 
// 배열 D[v] 에는 출발점 s로부터 점 v까지의 최소거리를 저장.

while(s로부터의 최단거리가 확정되지 않은 점이 있으면)
  현재까지 최단거리가 확정되지 않은 각 점 v에 대해서 최소의 D[v] 값을 지닌 점 Vmin을 선택하고, 
  s로부터 점 Vmin까지의 최단거리 D[Vmin]을 확정한다.
  s로부터 현재보다 짧은 거리로 점 Vmin을 통해 우회가능한 각 점 w에 대해서 D[W]를 갱신한다. //간선 완화

return D

```

📌 간선 완화 
- V-T에 속한 점들 중 Vmin을 거쳐 감(경유함)으로서 s로부터의 거리가 현재보다 더 짧아지는 점 w가 있다면,
그 점의 D[w]를 갱신.
- Vmin이 T에 포함된 상태에서 Vmin 에 인접한 점 w1,w2,w3 각각에 대해서 만일 (D[Vmin] + 간선 (v,wi)의 가중치) < D[wi] 이면, 
D[Wi] = (D[Vmin] + 간선 (v,wi)의 가중치) 로 갱신


**시간복잡도**
: prim 과 유사.
- (n-1) x {O(n)+O(n)} =O(n^2)
- 프림 알고리즘과 같이 최소 힙을 사용하면 O(mlogn), m은 간선 수. 따라서 간선 수가 O(n)이면 O(nlogn)

**증명**
![20220417051852](https://user-images.githubusercontent.com/86418674/163690406-526240ec-c306-479e-b532-cfef4aa39d2f.png)
![20220417052803](https://user-images.githubusercontent.com/86418674/163690410-c7eadea5-a966-484d-afc5-fcee4fefecfe.png)

![20220417051852](https://user-images.githubusercontent.com/86418674/163690168-2f71dd2f-8509-402d-9726-c6c0d01a8513.png)
